---
title: Java Junior — Тест на собеседование 2025-2026
tags:
  - java
  - interview
  - test
  - hashmap
  - concurrency
  - jmm
  - spring
---

# Тест: Java Junior Interview 2025-2026

Один тест с **вопросами с вариантами ответа** и **вопросами с открытым ответом**.  
Темы: hashCode/equals, HashMap, Concurrency, JMM, Java Core, Spring.

> [!info] Актуальность
> Тест обновлен для Java 21 LTS и Spring Boot 3.x. Включает современные практики и актуальные вопросы с собеседований 2025-2026.

**Навигация:** [[Java 2025-2026|← Java]] · [[../theory/topics_summary|Шпаргалка]]

---

## Часть A. Вопросы с вариантами ответа

Ответ пиши буквой (A/B/C/D) или кратко поясняй. Эталонные ответы — в свёрнутом блоке внизу.

---

### 1. Контракт equals–hashCode

Если два объекта равны по `equals()`, то они **обязаны** иметь одинаковый `hashCode()`. Верно ли обратное утверждение: «если у двух объектов одинаковый `hashCode()`, они обязаны быть равны по `equals()`»?

- **A)** Да, обязаны  
- **B)** Нет, не обязаны (достаточно того, что могут быть равны)  
- **C)** Верно только для объектов из одной и той же коллекции  
- **D)** Верно только для ключей `HashMap`

> [!example]- Твой ответ
> **Ответ:** _______

---

### 2. HashMap и null

Что из следующего **корректно** для `HashMap` в Java?

- **A)** Несколько ключей `null` и несколько значений `null`  
- **B)** Только один ключ `null`, значений `null` может быть много  
- **C)** Ни ключей, ни значений `null` быть не может  
- **D)** Ключей `null` не может быть, значений `null` — может быть несколько

> [!example]- Твой ответ
> **Ответ:** _______

---

### 3. Внутренняя структура HashMap (Java 8+)

При большом числе коллизий в одном бакете HashMap (Java 8+) может использовать не только связный список, но и другую структуру. Какую?

- **A)** Двоичная куча  
- **B)** Красно-чёрное дерево  
- **C)** B-дерево  
- **D)** Связный список используется всегда, структура не меняется

> [!example]- Твой ответ
> **Ответ:** _______

---

### 4. Load factor в HashMap

Какая **цель** у load factor в `HashMap`?

- **A)** Задать максимальное число коллизий в одном бакете  
- **B)** Определить момент рехеширования (увеличения массива бакетов) для баланса между памятью и числом коллизий  
- **C)** Задать начальную ёмкость  
- **D)** Ограничить максимальное число элементов в мапе

> [!example]- Твой ответ
> **Ответ:** _______

---

### 5. Потокобезопасность HashMap

Почему `HashMap` **не** рекомендуют использовать в многопоточном коде без внешней синхронизации?

- **A)** Потому что он не реализует интерфейс `Serializable`  
- **B)** Потому что при одновременной модификации возможны потеря данных, бесконечные циклы при rehash и т.п.  
- **C)** Потому что ключи должны быть иммутабельными  
- **D)** Потому что он хранит элементы в неупорядоченном виде

> [!example]- Твой ответ
> **Ответ:** _______

---

### 6. volatile и атомарность

Что гарантирует ключевое слово `volatile` для переменной?

- **A)** Атомарность любых операций, включая `i++`  
- **B)** Только видимость изменений между потоками и запрет переупорядочивания; атомарность составных операций не гарантируется  
- **C)** Взаимоисключение (mutual exclusion) при доступе к переменной  
- **D)** Сохранение значения в heap, а не в кэше процессора

> [!example]- Твой ответ
> **Ответ:** _______

---

### 7. Runnable vs Callable

Чем `Callable` отличается от `Runnable`?

- **A)** `Callable` выполняется в отдельном потоке, `Runnable` — только в главном  
- **B)** `Callable` возвращает результат и может бросать checked-исключения; `Runnable` — нет  
- **C)** `Callable` потокобезопасен, `Runnable` — нет  
- **D)** `Callable` допускает отмену задачи, `Runnable` — нет

> [!example]- Твой ответ
> **Ответ:** _______

---

### 8. ExecutorService: shutdown vs shutdownNow

В чём разница между `shutdown()` и `shutdownNow()` у `ExecutorService`?

- **A)** `shutdown()` останавливает пул немедленно, `shutdownNow()` — после завершения всех задач  
- **B)** `shutdown()` перестаёт принимать новые задачи и даёт доработать уже поданные; `shutdownNow()` пытается немедленно остановить пул и возвращает список невыполненных задач  
- **C)** Оба метода делают одно и то же  
- **D)** `shutdown()` только для `ScheduledExecutorService`, `shutdownNow()` — для обычного `ExecutorService`

> [!example]- Твой ответ
> **Ответ:** _______

---

### 9. Happens-before и volatile

Согласно JMM, какое из утверждений о **volatile** верно?

- **A)** Запись в volatile-переменную happens-before последующего чтения этой же переменной в любом потоке  
- **B)** volatile гарантирует атомарность операций вида `x = x + 1`  
- **C)** volatile запрещает использование кэша процессора только для этой переменной  
- **D)** volatile обеспечивает взаимное исключение доступа к переменной

> [!example]- Твой ответ
> **Ответ:** _______

---

### 10. Overloading vs Overriding

Чем **overloading** отличается от **overriding**?

- **A)** Overloading — для статических методов, overriding — для instance-методов  
- **B)** Overloading разрешается на этапе компиляции (разные сигнатуры), overriding — во время выполнения (полиморфизм)  
- **C)** Overloading возможен только в одном классе, overriding — только при наследовании  
- **D)** Overloading не разрешён в Java, есть только overriding

> [!example]- Твой ответ
> **Ответ:** _______

---

### 11. Spring: IoC и DI

Что такое **Dependency Injection** в контексте Spring?

- **A)** Внедрение зависимостей в объект контейнером (через конструктор, сеттеры и т.д.), а не создание их самим объектом  
- **B)** Автоматическое создание всех бинов при старте приложения  
- **C)** Инъекция кода через аннотации  
- **D)** Внедрение конфигурации через переменные окружения

> [!example]- Твой ответ
> **Ответ:** _______

---

### 12. @Service, @Repository, @Component

Какая из аннотаций обычно **не** используется для размещения бина в Spring-контейнере?

- **A)** `@Component`  
- **B)** `@Service`  
- **C)** `@Repository`  
- **D)** Все перечисленные используются для регистрации бинов (стереотипы)

> [!example]- Твой ответ
> **Ответ:** _______

---

### 13. @SpringBootApplication

Что по сути объединяет аннотация `@SpringBootApplication`?

- **A)** Только component scanning  
- **B)** Конфигурацию, component scanning и auto-configuration  
- **C)** Только конфигурацию и встроенный сервер  
- **D)** Подключение к БД и настройку JPA

> [!example]- Твой ответ
> **Ответ:** _______

---

## Часть B. Вопросы с открытым ответом

Ответь своими словами (2–5 предложений). Потом сверься с эталоном и [[theory/topics_summary|шпаргалкой]].

---

### 14. Мутабельные ключи в HashMap

Почему использование **мутабельных** объектов в качестве ключей `HashMap` считается плохой практикой? Что может пойти не так?

> [!question] Твой ответ
> (напиши здесь)

---

### 15. ConcurrentModificationException

При каких действиях чаще всего возникает `ConcurrentModificationException`? Как его избежать при итерации по коллекции с возможной модификацией?

> [!question] Твой ответ
> (напиши здесь)

---

### 16. synchronized vs volatile

Когда уместно использовать только `volatile`, а когда нужен именно `synchronized`? Приведи краткие примеры ситуаций.

> [!question] Твой ответ
> (напиши здесь)

---

### 17. Отличие ConcurrentHashMap от «обычного» HashMap

Чем `ConcurrentHashMap` отличается от `HashMap` в плане многопоточности? Почему в многопоточном коде часто предпочитают его обёртке `Collections.synchronizedMap(map)`?

> [!question] Твой ответ
> (напиши здесь)

---

### 18. Spring: BeanFactory и ApplicationContext

Чем **BeanFactory** отличается от **ApplicationContext**? В каких случаях может быть важно это различие?

> [!question] Твой ответ
> (напиши здесь)

---

## Эталонные ответы

> [!success]- Развернуть эталоны (не подглядывай до конца теста)
> 
> ### Часть A
> 1. **B** — Одинаковый `hashCode` не обязан означать равенство по `equals` (коллизии). См. [[theory/topics_summary#1. hashCode() и equals()]].
> 2. **B** — Один `null`-ключ, много `null`-значений.
> 3. **B** — Красно-чёрное дерево при ≥8 элементах в бакете (и capacity ≥ 64). См. [[theory/topics_summary#2. HashMap]].
> 4. **B** — Load factor задаёт порог для rehash (по умолчанию 0.75).
> 5. **B** — Потеря данных, циклы при rehash и т.д. при конкурентной модификации.
> 6. **B** — Видимость и запрет переупорядочивания; составные операции не атомарны. См. [[theory/topics_summary#4. JMM (Java Memory Model)]].
> 7. **B** — Callable возвращает результат и может бросать checked-исключения.
> 8. **B** — shutdown: не принимаем новые, дорабатываем старые; shutdownNow: попытка немедленной остановки + список невыполненных.
> 9. **A** — Запись в volatile happens-before последующего чтения в любом потоке.
> 10. **B** — Overloading — компиляция (разные сигнатуры), overriding — рантайм (полиморфизм).
> 11. **A** — Внедрение зависимостей контейнером, а не создание их объектом.
> 12. **D** — Все три — стереотипы и используются для регистрации бинов.
> 13. **B** — Конфигурация + component scanning + auto-configuration.
> 
> ### Часть B (краткие эталоны)
> **14.** Если после помещения в map изменить поля ключа, используемые в `hashCode`/`equals`, изменится бакет и хеш. Поиск по «старому» ключу может не найти запись или поведение станет непредсказуемым.
> 
> **15.** Возникает при изменении коллекции во время итерации (итератор, for-each) без использования итератора для удаления. Избежать: `Iterator.remove()`, `removeIf`, копия коллекции для итерации, либо потокобезопасные структуры (напр. `ConcurrentHashMap`).
> 
> **16.** `volatile` — флаги, простые счётчики «только запись/только чтение», когда нужна только видимость. `synchronized` — взаимоисключение и атомарность составных операций (check-then-act, инкремент с проверкой).
> 
> **17.** `ConcurrentHashMap` — lock striping по бакетам, разные потоки работают с разными частями. `synchronizedMap` блокирует всю мапу на каждую операцию → меньше параллелизма. У CHM есть атомарные операции (`putIfAbsent`, `compute`).
> 
> **18.** `BeanFactory` — минимальный контейнер, ленивая инициализация. `ApplicationContext` — надстройка (события, AOP, i18n), обычно eager-инициализация. Важно для старта и памяти.

---

> [!tip] Как пользоваться
> Сначала реши тест сам, затем разверни эталоны и сверь ответы. Ошибки и уточнения записывай в [[notes/my_notes|заметки]]. Можно прислать ответы на проверку — помогу дополнить и структурировать заметки.
