---
title: Java Junior — Шпаргалка по темам
tags:
  - java
  - interview
  - theory
  - hashCode
  - hashmap
  - concurrency
  - jmm
  - spring
---

# Java Junior — Шпаргалка по темам собеседования

Краткая выжимка по темам от тимлида + Java Core и Spring. Используй для подготовки и как основу для заметок при проверке.

**Навигация:** [[README|← Главная]] · [[test/java_junior_interview_test|Тест]] · [[notes/my_notes|Заметки]]

---

## 1. hashCode() и equals()

### Контракт equals–hashCode
- Если два объекта **равны** по `equals()`, у них **обязан** быть одинаковый `hashCode()`.
- Обратное неверно: одинаковый `hashCode` не значит, что объекты равны (коллизия).

### Свойства equals()
- Рефлексивность: `a.equals(a)` → true  
- Симметричность: `a.equals(b)` ⟺ `b.equals(a)`  
- Транзитивность: `a.equals(b)` ∧ `b.equals(c)` ⇒ `a.equals(c)`  
- Консистентность: повторные вызовы без изменений дают тот же результат  
- Сравнение с `null`: всегда `false`

> [!tip] Когда переопределять?
> - Для **кастомных объектов**, которые используются как ключи в `HashMap`/`HashSet` или участвуют в сравнении.  
> - Переопределять **всегда вместе**: и `equals`, и `hashCode`.

> [!warning] Частые ошибки
> - Переопределить только `equals` или только `hashCode` → некорректная работа в hash-коллекциях.
> - Использовать **мутабельные** объекты как ключи: изменение поля после добавления ломает поиск по ключу.

---

## 2. HashMap

### Внутреннее устройство (Java 8+)
- Массив **бакетов** (корзин). Каждый бакет — связный список; при ≥8 элементах в бакете и capacity ≥ 64 — **красно-чёрное дерево**.
- Хранится: `key`, `value`, `hash`, ссылка на следующий узел.

### Основные параметры
- **Load factor** (по умолчанию 0.75): при `size ≥ capacity * loadFactor` делается **rehash** (удвоение массива).
- Допускается **один** `null`-ключ, **много** `null`-значений.
- Дубликат ключа → новое значение **заменяет** старое.

### Коллизии
- Разные ключи с одинаковым `hashCode` попадают в один бакет (список/дерево).  
- В среднем **O(1)** для get/put, в худшем случае (много коллизий) — **O(n)**.

> [!warning] Потокобезопасность
> - **HashMap не потокобезопасен.** При одновременной модификации из разных потоков возможны потеря данных и бесконечные циклы при rehash.
> - Итерация + изменение без итератора → `ConcurrentModificationException`.
> - В многопоточности используют **ConcurrentHashMap** (lock striping по бакетам).

---

## 3. Concurrency / Multithreading

### Создание потоков
- Наследование от `Thread`, реализация `Runnable` или `Callable` + `ExecutorService` (предпочтительно в проде).

### Runnable vs Callable
- **Runnable**: не возвращает значение, не бросает checked-исключения.  
- **Callable**: возвращает результат через `Future`, может бросать checked-исключения.

### synchronized vs volatile
- **synchronized**: взаимоисключение (только один поток в блоке) + гарантии видимости (happens-before).  
- **volatile**: только **видимость** изменений между потоками, без блокировок. Не даёт атомарности составных операций (например, `i++`).

### ExecutorService / пулы потоков
- **execute()**: запуск задачи без результата, исключения можно "потерять".  
- **submit()**: возвращает `Future`, можно получить результат и обработать исключения.  
- **shutdown()**: перестаём принимать новые задачи, уже поданные дорабатывают.  
- **shutdownNow()**: попытка немедленной остановки, возвращает список невыполненных задач.

> [!warning] Типичные ошибки
> - Вызов `run()` вместо `start()` — код выполняется в текущем потоке, новый поток не создаётся.  
> - Неправильная настройка пула → голодание потоков или утечки.

---

## 4. JMM (Java Memory Model)

### Зачем нужна JMM
- Описывает, как потоки взаимодействуют через память: видимость записей, переупорядочивание инструкций компилятором/процессором, правила синхронизации.

### Проблемы без JMM
- **Видимость**: обновления одной нити могут быть не видны другим (кэш CPU, буферы записи).  
- **Переупорядочивание**: оптимизации компилятора/CPU могут менять порядок операций и ломать многопоточную логику.

### Happens-before
- **Program order**: действия в одном потоке упорядочены.  
- **Monitor lock**: unlock происходит-before последующего lock на том же мониторе.  
- **Volatile**: запись в `volatile` happens-before последующего чтения той же переменной.  
- **Thread start**: `start()` happens-before любых действий в стартованной нити.  
- **Thread join**: все действия в нити happen-before возврата из `join()` в вызвавшем потоке.

### volatile
- Запрещает кэширование переменной в регистрах/кэше.  
- Запрещает переупорядочивание относительно этой переменной.  
- Подходит для флагов, простых счётчиков; для составных операций — обычно нужен `synchronized` или атомарные классы.

---

## 5. Java Core

### ООП
- Инкапсуляция, наследование, полиморфизм, абстракция.

### Overloading vs Overriding
- **Overloading**: одно имя метода, разные сигнатуры (параметры). Разрешается **на этапе компиляции**.  
- **Overriding**: переопределение метода предка. Разрешается **в рантайме** (dynamic dispatch).  
- Статические методы **не переопределяются** (переопределяется поведение класса, не полиморфизм экземпляров).

### String Pool
- Литералы строк хранятся в heap в общем пуле. Повторное использование того же литерала даёт ссылку на тот же объект.  
- `"a" + "b"` при константах может быть свернуто в `"ab"` на этапе компиляции.

### Интерфейсы vs абстрактные классы
- **Интерфейс**: контракт, только объявление методов (и default/static при необходимости), нет состояния.  
- **Абстрактный класс**: может иметь поля, конструкторы, реализованные и абстрактные методы. Одно наследование.

### Collections
- **List**: упорядоченная, с дубликатами (ArrayList, LinkedList).  
- **Set**: без дубликатов (HashSet, LinkedHashSet, TreeSet).  
- **Map**: пары ключ–значение (HashMap, LinkedHashMap, TreeMap, ConcurrentHashMap).

---

## 6. Java Spring

### IoC (Inversion of Control)
- Управление объектами и их зависимостями передано контейнеру. Код не создаёт зависимости сам, а получает их извне.

### DI (Dependency Injection)
- Внедрение зависимостей через конструктор, сеттеры или поля. Spring реализует IoC через DI.

### Spring-бины
- Объекты, которые создаёт и управляет контейнер Spring. Настраиваются через XML, аннотации или Java-конфиг.

### ApplicationContext vs BeanFactory
- **BeanFactory**: базовый контейнер, ленивая инициализация.  
- **ApplicationContext**: надстройка, добавочная функциональность (события, интеграция с AOP, i18n и т.д.), по умолчанию eager-инициализация бинов.

### Стереотипы
- `@Component` — общий компонент.  
- `@Service` — слой сервисов.  
- `@Repository` — слой доступа к данным (в т.ч. исключения → DataAccessException).  
- `@Controller` / `@RestController` — слой веб (REST = Controller + ResponseBody).

### Spring Boot
- **@SpringBootApplication**: конфигурация + component scan + auto-configuration.  
- **Starters**: готовые наборы зависимостей (spring-boot-starter-web, -data-jpa и т.д.).  
- **Auto-configuration**: автоматическая настройка бинов по classpath.  
- Встроенный сервер (Tomcat и др.), упрощённая разработка REST API.

### Spring MVC
- **DispatcherServlet** принимает запрос, ищет контроллер по маппингу, возвращает View или тело ответа (REST).

---

## Как пользоваться

> [!tip] Перед тестом
> Прочитай разделы по темам, повтори ключевые определения.

> [!tip] Во время проверки
> Отвечай своими словами; если что-то забыл — смотри сюда или в [[test/java_junior_interview_test|тест]] (эталоны).

> [!tip] После проверки
> Добавляй в [[notes/my_notes|заметки]] слабые места и уточнения от проверяющего.
