---
title: Заметки по подготовке
tags:
  - java
  - interview
  - notes
---

# Мои заметки при подготовке

Здесь — заметки после прохождения [[test/java_junior_interview_test|теста]] и проверки. Добавляй то, что стоит повторить или запомнить.

**Навигация:** [[Interview Preparation 2025-2026|← Главная]] · [[theory/topics_summary|Шпаргалка]] · [[test/java_junior_interview_test|Тест]]

---

## После первого прохождения теста

> [!note] Результаты
> - **Дата:** _заполни_
> - **Правильных ответов (Часть A):** 9 из 13
> - **Ошибки:** Вопросы 1, 5, 7
> - **Нужно доучить:** Вопросы 15, 17, 18

---

## Темы, где были ошибки

### ❌ Вопрос 1: Контракт equals–hashCode (обратное утверждение)

**Твой ответ:** A (Да, обязаны)  
**Правильный ответ:** B (Нет, не обязаны)

**Почему ошибка:**
- Одинаковый `hashCode()` **не гарантирует** равенство по `equals()`.
- Это нормально и называется **коллизией** — разные объекты могут иметь одинаковый хеш.
- Контракт работает только в одну сторону: если `equals()` → true, то `hashCode()` должен быть одинаковым.
- Обратное неверно: одинаковый `hashCode()` → объекты могут быть разными.

**Пример:**
```java
String a = "Aa";
String b = "BB";
// У них одинаковый hashCode() (коллизия), но equals() вернёт false
```

**Что запомнить:** Коллизии в хеш-таблицах — это нормально. HashMap умеет их обрабатывать через списки/деревья в бакетах.

---

### ❌ Вопрос 5: Потокобезопасность HashMap

**Твой ответ:** C (Потому что ключи должны быть иммутабельными)  
**Правильный ответ:** B (Потеря данных, бесконечные циклы при rehash)

**Почему ошибка:**
- Проблема не в иммутабельности ключей (хотя это хорошая практика).
- Главная проблема — **конкурентная модификация** из разных потоков:
  - Потеря данных при одновременном `put()`
  - Бесконечные циклы при rehash (когда массив бакетов увеличивается)
  - Некорректное состояние внутренних структур

**Что запомнить:** HashMap не потокобезопасен из-за внутренней структуры, которая не защищена от одновременных изменений. Для многопоточности используй `ConcurrentHashMap`.

---

### ❌ Вопрос 7: Runnable vs Callable

**Твой ответ:** C (Callable потокобезопасен, Runnable — нет)  
**Правильный ответ:** B (Callable возвращает результат и может бросать checked-исключения)

**Почему ошибка:**
- Потокобезопасность не связана с различием между `Runnable` и `Callable`.
- Главные отличия:
  - `Runnable`: `void run()`, не возвращает результат, не бросает checked-исключения
  - `Callable<V>`: `V call() throws Exception`, возвращает результат через `Future`, может бросать checked-исключения

**Что запомнить:** `Callable` используется с `ExecutorService.submit()`, который возвращает `Future` для получения результата и обработки исключений.

---

### ⚠️ Вопрос 14: Мутабельные ключи в HashMap (частично верно)

**Твой ответ:** "при Хеше, ключ должен был уникальным и не мутабельным, что бы не случилась коллизия"

**Что не так:**
- Коллизии — это нормально и неизбежны (разные объекты могут иметь одинаковый хеш).
- **Реальная проблема:** если изменить поля ключа, которые используются в `hashCode()`/`equals()`, то:
  1. Хеш ключа изменится → ключ будет искать в другом бакете
  2. `get(key)` не найдёт запись, хотя она есть в мапе
  3. Может появиться дубликат ключа (старый и новый хеш)

**Правильный ответ:** После помещения ключа в map изменение его полей (используемых в `hashCode`/`equals`) меняет бакет и хеш. Поиск по "старому" ключу может не найти запись или поведение станет непредсказуемым.

**Пример:**
```java
Map<Person, String> map = new HashMap<>();
Person key = new Person("John", 25);
map.put(key, "value");
key.setAge(30); // Изменили поле, используемое в hashCode()
map.get(key); // Может не найти запись!
```

---

### ⚠️ Вопрос 16: synchronized vs volatile (частично верно)

**Твой ответ:** "synchronized когда нужно считывать и записывать, volatile когда только считывать"

**Что не так:**
- `volatile` не только для чтения — он обеспечивает **видимость** изменений между потоками.
- `volatile` можно и писать, но он **не даёт атомарности** составных операций (например, `i++`).

**Правильное понимание:**
- **`volatile`:** только видимость изменений между потоками + запрет переупорядочивания. Подходит для флагов, простых счётчиков "только запись/только чтение".
- **`synchronized`:** взаимоисключение (mutual exclusion) + атомарность составных операций (check-then-act, инкремент с проверкой).

**Примеры:**
- `volatile boolean flag = true;` — флаг для остановки потока ✅
- `volatile int counter; counter++;` — **НЕ атомарно**, нужен `synchronized` или `AtomicInteger` ❌
- `synchronized` блок для `if (count > 0) count--;` — атомарная проверка и изменение ✅

---

### ❓ Вопрос 15: ConcurrentModificationException

**Твой ответ:** не знаю

**Правильный ответ:**
- Возникает при изменении коллекции во время итерации (итератор, for-each) без использования итератора для удаления.
- **Как избежать:**
  1. `Iterator.remove()` для удаления во время итерации
  2. `removeIf()` для условного удаления
  3. Копия коллекции для итерации
  4. Потокобезопасные структуры (например, `ConcurrentHashMap`)

**Пример проблемы:**
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
for (String s : list) {
    list.remove(s); // ConcurrentModificationException!
}
```

**Правильно:**
```java
Iterator<String> it = list.iterator();
while (it.hasNext()) {
    if (it.next().equals("b")) {
        it.remove(); // OK
    }
}
```

---

### ❓ Вопрос 17: ConcurrentHashMap vs HashMap

**Твой ответ:** не знаю

**Правильный ответ:**
- **ConcurrentHashMap:** lock striping по бакетам — разные потоки работают с разными частями мапы параллельно. Есть атомарные операции (`putIfAbsent`, `compute`, `merge`).
- **Collections.synchronizedMap(map):** блокирует **всю мапу** на каждую операцию → меньше параллелизма, все потоки ждут друг друга.

**Почему предпочитают ConcurrentHashMap:**
- Лучшая производительность в многопоточности (параллельная работа с разными бакетами)
- Атомарные операции без дополнительных блокировок
- Меньше contention (конкуренции) между потоками

---

### ❓ Вопрос 18: BeanFactory vs ApplicationContext

**Твой ответ:** не знаю

**Правильный ответ:**
- **BeanFactory:** минимальный контейнер, **ленивая инициализация** бинов (создаются при первом обращении).
- **ApplicationContext:** надстройка над BeanFactory, добавляет:
  - События (ApplicationEvent)
  - Интеграцию с AOP
  - i18n (интернационализация)
  - Обычно **eager-инициализация** (бины создаются при старте)

**Когда важно различие:**
- Для старта приложения (ApplicationContext создаёт все бины сразу)
- Для памяти (BeanFactory экономит память, создавая бины по требованию)
- В Spring Boot используется `ApplicationContext` (через `@SpringBootApplication`)

---

## Что повторить перед собесом

- [ ] **Контракт equals–hashCode:** обратное утверждение неверно (коллизии нормальны)
- [ ] **Потокобезопасность HashMap:** причины (потеря данных, циклы при rehash), не иммутабельность ключей
- [ ] **Runnable vs Callable:** различия (результат, исключения), не потокобезопасность
- [ ] **Мутабельные ключи:** проблема не в коллизиях, а в изменении хеша после добавления
- [ ] **synchronized vs volatile:** volatile для видимости, synchronized для атомарности
- [ ] **ConcurrentModificationException:** причины и способы избежать
- [ ] **ConcurrentHashMap:** lock striping, отличие от synchronizedMap
- [ ] **BeanFactory vs ApplicationContext:** ленивая vs eager-инициализация, дополнительная функциональность

---

## Формулировки на память

> [!tip] Ключевые фразы
> - **equals–hashCode:** "Одинаковый hashCode не гарантирует равенство по equals (коллизии нормальны)"
> - **HashMap потокобезопасность:** "Не потокобезопасен из-за потери данных и циклов при rehash при конкурентной модификации"
> - **Runnable vs Callable:** "Callable возвращает результат и может бросать checked-исключения"
> - **Мутабельные ключи:** "Изменение полей ключа после добавления меняет бакет → поиск не найдёт запись"
> - **volatile:** "Только видимость, не атомарность. Для составных операций нужен synchronized"
> - **ConcurrentHashMap:** "Lock striping по бакетам → параллелизм. synchronizedMap блокирует всю мапу"

---

## Свободные заметки

_Добавляй сюда новые блоки после каждой проверки. Можно вставлять ссылки на [[theory/topics_summary|шпаргалку]] по конкретным разделам._
